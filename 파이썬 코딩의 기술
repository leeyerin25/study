1. pep8 스타일
- 부정을 안에 넣기 : if not a is b --> if a is not b
- 임포트 적는 순서 : 표준 - 서드파티 - 직접만든

2.bytes 와 str 차이
- bytes : 이진파일처리 , str : 사람의 언어 처리
- 두개는 호환이 안됨
- ? : 유니코드 샌드위치??

3.f-문자열을 통한 인터폴레이션을 사용
- 형식화 : 미리 정의한 문자열에 데이터 값을 끼워 넣는것  ex) % (넣을것1 , 넣을것2)
- 순서정하기위해 키 지정 가능 : % (지정 키 1 : 넣을것1 , 지정 키 2 : 넣을것2)
- 동일 키 두번쓰면 반복해서 표현 가능

-내장함수 formate ex) {}.format(1.23)
- 이때 정의한 문자열애 위치 인덱스 지정 가능 {1} = {0}.format(3,5)  # 5 = 3

4.대입을 사용해 데이터를 언패킹하라
- 튜플은 인덱스를 통해 새 값을 대입해 튜플 변경 불가!! ex) pair = ('first', 'second') /n pari[0] = 'third' #이거 불가
- 대신 언패킹 사용 ex) fir, sec = pair /n print(fir) # first
- 리스트,시퀀스 등 이터러블(?)이 들어간 경우에도 가능. ?: 데이터프레임에도 이용이 가능한가?
- ? : 네값 이상은 언패킹 말라

5. enumarate
- for i,item in enumerate(list, 1): #1처럼 어디서부터 원소를 가져올지 지정 가능

6.zip
- zip_longest : 리스트의 길이가 다른경우 가장 긴것만큼 돌려줌



3/31

1.시퀀스 슬라이싱
- 슬라이싱시 끝 인덱스는 포함 안됨

2.스트라이드랑 슬라이스 한식에 ㄴㄴ
- x[::2] 는 0번째 기준 2개씩 증가시킴

3.시퀀스 슬라이싱 방법
- 슬라이싱으로 얻은 리스트는 변경해도 길이 그대로?
- 원본 리스트는 변경하면 추가되서 길이 변경됨?

4.언패킹시에는 별표식을 사용하자. (대입이 안된 남은 애들을 마저 잡아냄)
- 고유값만 닮을수있게해줌 ex)a,b,*c=cars
- 별표는 a 나 b 에도 쓸수있음
- 중복이나 오류를 줄여줌
- 별표식은 늘 list 형태
- 함수의 반환값이 여러줄일경우에 유용

5.복잡한 기준을 정렬할때는 key 파라미터 사용
- 리스트.sort(key lambda x: x.name)  (name은 Dict의 키이름)

6.in 대신 get사용
- 리스트.get(key,0) #여기서 두번째 인자는 딕셔너리에없을때 돌려줄 디폴트값


7. 대입식을 사용해 반복을 피하라 (?)
- 왈러스 :=
- if 문 들어가기전 변수를 미리 지정할 필요 없이 if 문 안에서 변수를 지정해하는것

